import fs from "fs";
import upath from "upath";
import { configFolder, configOverridesFolder, rootDirectory, templatesFolder } from "../../globals";
import mustache from "mustache";
import gulp from "gulp";
import { checkEnvironmentalVariables } from "../../util/util";

// This updates all the files, for a release.

// IF DEBUGGING:
// Change debug value to true
// Change version to a string
const debug = false;
const version: string = process.env.VERSION;

// If it is not a release, and thus no changes to versions need to be made.
// This occurs when the files are to be updated from the templates outside of a release.
// Optional variable to set.
let notRelease = false;

/**
 * Checks if env variable are set, creates versions.txt if file does not exist, and checks if new version already exists in versions.txt.
 */
export async function check(): Promise<void> {
	if (!debug) {
		checkEnvironmentalVariables(["VERSION"]);
	}
	const versionsFilePath: string = upath.join(templatesFolder, "versions.txt");

	if (notRelease) {
		console.log("Detected that this is not a release commit.");
		console.log("Version info will not change, but the files will be updated from the template.");
		await checkNotRelease(versionsFilePath);
	} else {
		console.log("Detected that this is a release commit.");
		await checkRelease(versionsFilePath);
	}
}

/**
 * Sets this workflow as a non-release.
 */
export async function setNotRelease(): Promise<void> {
	notRelease = true;
}

// Checks for non-release commits
async function checkNotRelease(versionsFilePath: string) {
	// Check if versions.txt exists
	if (!fs.existsSync(versionsFilePath)) {
		console.error(
			`Version.txt does not exist. Creating empty file, and adding ${version} to it. This may be an error.`,
		);

		// Create Versions.txt, with version
		await fs.promises.writeFile(versionsFilePath, `        - ${version}`);
	} else {
		// Check for duplicate entries
		const versionList = await fs.promises.readFile(versionsFilePath, "utf8");

		// No Duplicate Key
		if (!versionList.includes(version)) {
			console.error(`Version is not in version.txt. Adding ${version} to version.txt. This may be an error.`);
		}
	}
}

// Checks for release Commits
async function checkRelease(versionsFilePath: string) {
	// Check if versions.txt exists
	if (!fs.existsSync(versionsFilePath)) {
		console.error("Version.txt does not exist. Creating empty file. This may be an error.");

		// Create Versions.txt
		fs.closeSync(fs.openSync(versionsFilePath, "w"));
	} else {
		// Check for duplicate entries
		const versionList = await fs.promises.readFile(versionsFilePath, "utf8");

		// Duplicate Key
		if (versionList.includes(version)) {
			throw new Error("Version already exists in version.txt. Exiting...");
		}
	}
}

/**
 * @param readPath The filepath to read from. (Template)
 * @param writePaths The filepaths to write to.
 * @param replacementObject A record, of type string to type unknown, containing the keys, and replacement for those keys
 * <p>
 * <p>
 * Pattern regExps[0] will be replaced by replacements[0], etc.
 * <p>
 * <p>
 * A warning not to edit the file will also be added to the start of the file.
 */
async function modifyFile(readPath: string, writePaths: string[], replacementObject: Record<string, unknown>) {
	// Read the file content
	const data: string = await fs.promises.readFile(readPath, "utf8");

	// Moustache Render
	let modifiedData: string = mustache.render(data, replacementObject);

	// Add warning to not edit file
	modifiedData = `# DO NOT EDIT THIS FILE! EDIT THE TEMPlATES INSTEAD!
# View the CONTRIBUTING.md file on this project's root directory for more information!
${modifiedData}`;

	// Write the modified content back to the file
	for (const filename of writePaths) {
		await fs.promises.writeFile(filename, modifiedData, "utf8");
	}
}

export async function updateIssueTemplates(): Promise<void> {
	// Filenames
	const fileNames: string[] = ["001-bug-report.yml", "002-feature-request.yml"];

	const versionsFilePath: string = upath.join(templatesFolder, "versions.txt");

	let versionList: string = await fs.promises.readFile(versionsFilePath, "utf8");

	if (!notRelease) {
		// Add new version to list, with indent
		versionList = `        - ${version}\n${versionList}`;
	}

	// Replacement Object
	const replacementObject: Record<string, unknown> = {
		versions: versionList,
	};

	// Write updated Version List
	await fs.promises.writeFile(versionsFilePath, versionList);

	const issueTemplatesFolder: string = upath.join(rootDirectory, ".github", "ISSUE_TEMPLATE");

	// Write to issue templates
	for (const fileName of fileNames) {
		const readPath = upath.join(templatesFolder, fileName);
		const writePath = upath.join(issueTemplatesFolder, fileName);
		await modifyFile(readPath, [writePath], replacementObject);
	}
}

export async function updateRandomPatchesConfig(): Promise<void> {
	// Filename & paths
	const fileName = "randompatches.cfg";
	const readPath: string = upath.join(templatesFolder, fileName);
	const writePathsNormal: string[] = [
		upath.join(rootDirectory, configFolder, fileName),
		upath.join(rootDirectory, configOverridesFolder, "normal", fileName),
	];

	// Replacement object
	const replacementObject: Record<string, unknown> = {
		version: version,
		mode: "Normal",
	};

	// Modify Normal File
	await modifyFile(readPath, writePathsNormal, replacementObject);

	// Change values for Expert Config
	replacementObject["mode"] = "Expert";
	const writePathExpert = upath.join(rootDirectory, configOverridesFolder, "expert", fileName);

	// Modify Expert File
	await modifyFile(readPath, [writePathExpert], replacementObject);
}

export async function updateServerProperties(): Promise<void> {
	// File name of the output files
	const fileName = "server.properties";

	// File name of the Normal Template File
	const fileNameNormal = "server_normal.properties";

	// File name of the Expert Template File
	const fileNameExpert = "server_expert.properties";

	// Replacement Object
	const replacementObject: Record<string, unknown> = {
		version: version,
	};

	// Read and Write paths for normal
	const readPathNormal: string = upath.join(templatesFolder, fileNameNormal);
	const writePathsNormal: string[] = [
		upath.join(rootDirectory, "serverfiles", fileName),
		upath.join(rootDirectory, configOverridesFolder, "normal", fileName),
	];

	// Modify Normal File
	await modifyFile(readPathNormal, writePathsNormal, replacementObject);

	// Read and Write paths for expert
	const readPathExpert: string = upath.join(templatesFolder, fileNameExpert);
	const writePathExpert: string = upath.join(rootDirectory, configOverridesFolder, "expert", fileName);

	// Modify Expert File
	await modifyFile(readPathExpert, [writePathExpert], replacementObject);
}

export const updateAll = gulp.series(updateIssueTemplates, updateRandomPatchesConfig, updateServerProperties);
